#变量的解构赋值
#
##1、数组的解构赋值
###基本用法
>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，称为解构。

	var [a,b,c]=[1,2,3];
	//分别为a,b,c赋值1，2，3

>本质上，此写法类似于"模式匹配",只要等号两边的模式相同，左边的变量会被赋予对应的值。

	let [,,third]=["foo","bar","baz"];
	console.log(third);//"baz"

	let [head,...tail]=[1,2,3,4];
	console.log(tail);//[2,3,4]

	let [x,y,...z]=['a'];
	console.log(x);//"a"
	console.log(y);//undefined
	console.log(z);//[]
>如果解构不成功，变量的值就等于`undefined`.

	var [foo]=[];
	console.log(foo);//undefined
	var [bar,foo]=[1];
	console.log(foo);//undefined
>不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然成功。

	let [x,y]=[1,2,3];
	console.log(x);//1
	console.log(y);//2

	let [a,[b],c]=[1,[2,3],4];
	console.log(b);//2
>等号右边不是数组(不是可遍历的结构)，将会报错。

	let [foo] = 1;
	let [foo] = false;
	let [foo] = NaN;
	let [foo] = undefined;
	let [foo] = null;
	let [foo] = {};
	//等号右边的值，要么转为对象后不具备Iterator接口，要么本身不具备Iterator接口。
>解析赋值适用于`var`,`let`,`const`命令,对`Set`结构，也可以使用数组的解构赋值。

	var [v1,v2,...,vn]=array;
	let [v1,v2,...,vn]=array;
	const [v1,v2,...,vn]=array;
	let [x,y,z]=new Set(["a","b","c"]);

>只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。

	function* fibs() {
	  var a = 0;
	  var b = 1;
	  while (true) {
	    yield a;
	    [a, b] = [b, a + b];
	  }
	}
	
	var [first, second, third, fourth, fifth, sixth] = fibs();
	console.log(sixth); // 5
	//fibs是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。

###默认值
>解构赋值允许指定默认值。

	
	var [foo=true]=[];
	console.log(foo);//true
	
	var [x,y='b']=['a',undefined];
	console.log(x);//'a'
	console.log(y);//'b'

>ES6内部使用严格相等运算符（`===`）,判断一个位置是否有值。如果一个数组成员不严格等于`undefined`，默认值是不会生效的。

	var [x=1]=[undefined];
	console.log(x);//1

	var [x=1]=[null];
	console.log(x);//null

>如果默认值是一个表达式，那么表达式是惰性求值的，即只有在用到的时候，才会求值。

	function f() {
		console.log('aaa');
	}
	
	let [x=f()]=[1];
	console.log(x);//1


>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。

	let [x=1,y=x]=[];
	console.log(x);//1
	console.log(y);//1

	let [x=1,y=x]=[1,2];
	console.log(x);//1
	console.log(y);//2

	let [x=y,y=1]=[];
	console.log(x);//ReferenceError
	console.log(y);

##2、对象的解构赋值
>解构不仅可以用于数组，还可以用于对象。

	var {foo,bar}={foo:"abc",bar:"def"};
	console.log(foo);//"abc"
	console.log(bar);//"def"
>对象的解构和数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定。而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

	var {bar,foo}={foo:"aaa",bar:"bbb"};
	console.log(foo);//"aaa"
	console.log(bar);//"bbb"