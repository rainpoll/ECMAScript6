#变量的解构赋值
#
##1、数组的解构赋值
###基本用法
>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，称为解构。

	var [a,b,c]=[1,2,3];
	//分别为a,b,c赋值1，2，3

>本质上，此写法类似于"模式匹配",只要等号两边的模式相同，左边的变量会被赋予对应的值。

	let [,,third]=["foo","bar","baz"];
	console.log(third);//"baz"

	let [head,...tail]=[1,2,3,4];
	console.log(tail);//[2,3,4]

	let [x,y,...z]=['a'];
	console.log(x);//"a"
	console.log(y);//undefined
	console.log(z);//[]
>如果解构不成功，变量的值就等于`undefined`.

	var [foo]=[];
	console.log(foo);//undefined
	var [bar,foo]=[1];
	console.log(foo);//undefined
>不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然成功。

	let [x,y]=[1,2,3];
	console.log(x);//1
	console.log(y);//2

	let [a,[b],c]=[1,[2,3],4];
	console.log(b);//2
>等号右边不是数组(不是可遍历的结构)，将会报错。

	let [foo] = 1;
	let [foo] = false;
	let [foo] = NaN;
	let [foo] = undefined;
	let [foo] = null;
	let [foo] = {};
	//等号右边的值，要么转为对象后不具备Iterator接口，要么本身不具备Iterator接口。
>解析赋值适用于`var`,`let`,`const`命令,对`Set`结构，也可以使用数组的解构赋值。

	var [v1,v2,...,vn]=array;
	let [v1,v2,...,vn]=array;
	const [v1,v2,...,vn]=array;
	let [x,y,z]=new Set(["a","b","c"]);

>只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。

	function* fibs() {
	  var a = 0;
	  var b = 1;
	  while (true) {
	    yield a;
	    [a, b] = [b, a + b];
	  }
	}
	
	var [first, second, third, fourth, fifth, sixth] = fibs();
	console.log(sixth); // 5
	//fibs是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。


